plugins {
    id "com.github.johnrengelman.shadow"
    id 'org.jetbrains.kotlin.jvm'
}

architectury {
    platformSetupLoomIde()
    forge()
}

loom {
    accessWidenerPath = project(":common").loom.accessWidenerPath

    forge {
        convertAccessWideners = true
        extraAccessWideners.add loom.accessWidenerPath.get().asFile.name

        mixinConfig "aris-common.mixins.json"
        mixinConfig "aris.mixins.json"
    }
}

repositories {
    // Add KFF Maven repository
    maven {
        name = 'Kotlin for Forge'
        url = 'https://thedarkcolour.github.io/KotlinForForge/'
    }
}

configurations {
    common
    shadowCommon // Don't use shadow from the shadow plugin since it *excludes* files.
    compileClasspath.extendsFrom common
    runtimeClasspath.extendsFrom common
    developmentForge.extendsFrom common
}

dependencies {
    forge "net.minecraftforge:forge:${rootProject.forge_version}"

    common(project(path: ":common", configuration: "namedElements")) { transitive false }
    shadowCommon(project(path: ":common", configuration: "transformProductionForge")) { transitive = false }
    compileOnly "org.jetbrains.kotlin:kotlin-stdlib-jdk8"

    forgeRuntimeLibrary("me.ddayo:aris.luagen") { transitive false }
    compileOnly "me.ddayo:aris.luagen"
    shadowCommon("me.ddayo:aris.luagen") { transitive false }
    forgeRuntimeLibrary 'party.iroiro.luajava:luajit-platform:4.0.2:natives-desktop'
    runtimeOnly 'party.iroiro.luajava:luajit-platform:4.0.2:natives-desktop'
    shadowCommon 'party.iroiro.luajava:luajit-platform:4.0.2:natives-desktop'
    implementation 'thedarkcolour:kotlinforforge:4.11.0'
    compileOnly 'party.iroiro.luajava:luajit:4.0.2'
    shadowCommon 'party.iroiro.luajava:luajit:4.0.2'
    forgeRuntimeLibrary 'party.iroiro.luajava:luajit:4.0.2'
}

processResources {
    inputs.property "version", project.version

    filesMatching("META-INF/mods.toml") {
        expand "version": project.version
    }
}

shadowJar {
    exclude "fabric.mod.json"
    exclude "architectury.common.json"

    configurations = [project.configurations.shadowCommon]
    archiveClassifier = "dev-shadow"
}

remapJar {
    input.set shadowJar.archiveFile
    dependsOn shadowJar
}

sourcesJar {
    def commonSources = project(":common").sourcesJar
    dependsOn commonSources
    from commonSources.archiveFile.map { zipTree(it) }
}

components.java {
    withVariantsFromConfiguration(project.configurations.shadowRuntimeElements) {
        skip()
    }
}

publishing {
    publications {
        mavenForge(MavenPublication) {
            artifactId = rootProject.archives_base_name + "-" + project.name
            from components.java
        }
    }

    // See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
    repositories {
        // Add repositories to publish to here.
    }
}
repositories {
    mavenCentral()
}
kotlin {
    jvmToolchain(17)
}

// SJhub start - custom mc client for fix native lib loading issue
import groovy.json.JsonSlurper

static def getForgeVersionId(forgeVersion) {
    def parts = forgeVersion.split("-")
    if (parts.length >= 2) {
        return "${parts[0]}-forge-${parts[1]}"
    }
    return forgeVersion
}

ext {
    mcVersion = "1.20.1"
    mcLibrariesDir = file("aris_run/libraries")
    mcAssetsDir = file("aris_run/assets")
    mcNativesDir = file("aris_run/natives")
    mcVersionDir = file("aris_run/versions")
    forgeVersion = "${project.forge_version}"
    forgeInstallerDir = file("forge-installer")
    forgeVersionId = getForgeVersionId(forgeVersion)
}

tasks.register("downloadMinecraftDependencies") {
    group = "aris"
    description = "Download all Minecraft ${mcVersion} dependencies for Aris Client."

    doLast {
        println "=== Downloading Minecraft ${mcVersion} Dependencies ==="

        def versionData = getVersionData(mcVersion)
        def totalLibraries = versionData.libraries.size()
        def downloaded = 0

        versionData.libraries.eachWithIndex { library, index ->
            print "\r[ARIS] Downloading libraries: ${index + 1}/${totalLibraries}"

            if (library.downloads?.artifact) {
                downloadArtifact(library.downloads.artifact, mcLibrariesDir)
            }

            if (library.downloads?.classifiers) {
                def classifier = getOsClassifier()
                if (library.downloads.classifiers[classifier]) {
                    def nativeDir = library.downloads.classifiers[classifier]
                    downloadArtifact(nativeDir, mcLibrariesDir)

                    extractNatives(new File(mcLibrariesDir, nativeDir.path), mcNativesDir)
                }
            }

            if (library.rules) {
                if (!checkRules(library.rules)) {
                    return
                }
            }
        }

        println "\n[ARIS] Libraries downloaded!"

        if (versionData.downloads?.client) {
            def clientJar = new File(mcVersionDir, "${mcVersion}/${mcVersion}.jar")
            clientJar.parentFile.mkdirs()

            println "[ARIS] Downloading client JAR..."
            new URL(versionData.downloads.client.url).withInputStream { input ->
                clientJar.withOutputStream { output ->
                    output << input
                }
            }
            println "[ARIS] Client JAR downloaded!"
        }

        downloadAssets(versionData)

        println "\n=== Download Complete ==="
        println "[ARIS] Libraries: ${mcLibrariesDir.absolutePath}"
        println "[ARIS] Assets: ${mcAssetsDir.absolutePath}"
        println "[ARIS] Natives: ${mcNativesDir.absolutePath}"
    }
}

static def getVersionData(version) {
    def manifestUrl = 'https://launchermeta.mojang.com/mc/game/version_manifest_v2.json'
    def manifest = new JsonSlurper().parse(new URL(manifestUrl))
    def versionInfo = manifest.versions.find { it.id == version }

    if (!versionInfo) {
        throw new GradleException("Version ${version} not found!")
    }

    return new JsonSlurper().parse(new URL(versionInfo.url))
}

static def downloadArtifact(artifact, baseDir) {
    def targetFile = new File(baseDir, artifact.path)

    if (!targetFile.exists()) {
        targetFile.parentFile.mkdirs()
        new URL(artifact.url).withInputStream { input ->
            targetFile.withOutputStream { output ->
                output << input
            }
        }
    }
}

def extractNatives(zipFile, targetDir) {
    targetDir.mkdirs()

    ant.unzip(src: zipFile, dest: targetDir) {
        patternset {
            exclude(name: "META-INF/")
        }
    }
}

static def checkRules(rules) {
    def allow = false

    rules.each { rule ->
        if (rule.action == "allow") {
            if (!rule.os || checkOs(rule.os)) {
                allow = true
            }
        } else if (rule.action == "disallow") {
            if (!rule.os || checkOs(rule.os)) {
                allow = false
            }
        }
    }

    return allow
}

static def checkOs(osRule) {
    def currentOs = System.getProperty("os.name").toLowerCase()

    if (osRule.name == "windows" && currentOs.contains("win")) return true
    if (osRule.name == "osx" && currentOs.contains("mac")) return true
    if (osRule.name == "linux" && currentOs.contains("linux")) return true

    return false
}

def downloadAssets(versionData) {
    def assetIndex = versionData.assetIndex
    def indexFile = new File(mcAssetsDir, "indexes/${assetIndex.id}.json")
    indexFile.parentFile.mkdirs()

    println "[ARIS] Downloading asset index: ${assetIndex.id}"
    new URL(assetIndex.url).withInputStream { input ->
        indexFile.withOutputStream { output ->
            output << input
        }
    }

    def indexData = new JsonSlurper().parse(indexFile)
    def objectsDir = new File(mcAssetsDir, "objects")
    def totalAssets = indexData.objects.size()
    def downloadedAssets = 0

    println "[ARIS] Downloading ${totalAssets} asset files..."

    indexData.objects.each { name, assetInfo ->
        def hash = assetInfo.hash
        def subdir = hash.substring(0, 2)
        def targetFile = new File(objectsDir, "${subdir}/${hash}")

        if (!targetFile.exists()) {
            targetFile.parentFile.mkdirs()
            def url = "https://resources.download.minecraft.net/${subdir}/${hash}"

            try {
                new URL(url).withInputStream { input ->
                    targetFile.withOutputStream { output ->
                        output << input
                    }
                }
            } catch (Exception e) {
                println "\n[ARIS] Failed to download asset: ${name} - ${e.message}"
            }
        }

        downloadedAssets++
        if (downloadedAssets % 100 == 0 || downloadedAssets == totalAssets) {
            print "\r[ARIS] Progress: ${downloadedAssets}/${totalAssets} assets"
        }
    }

    println "\n[ARIS] Assets download complete!"
}

static def getOsClassifier() {
    def os = System.getProperty("os.name").toLowerCase()
    if (os.contains("win")) return "natives-windows"
    else if (os.contains("mac")) return "natives-macos"
    else if (os.contains("linux")) return "natives-linux"
    else return "natives-linux"
}

tasks.register("downloadForgeInstaller") {
    group = "aris"

    def installerFile = new File(forgeInstallerDir, "forge-${forgeVersion}-installer.jar")

    doLast {
        forgeInstallerDir.mkdirs()

        def forgeUrl = "https://maven.minecraftforge.net/net/minecraftforge/forge/${forgeVersion}/forge-${forgeVersion}-installer.jar"

        if (!installerFile.exists()) {
            println "[ARIS] Downloading Forge installer: ${forgeVersion}"
            new URL(forgeUrl).withInputStream { input ->
                installerFile.withOutputStream { output ->
                    output << input
                }
            }
            println "[ARIS] Forge installer downloaded!"
        } else {
            println "[ARIS] Forge installer already exists"
        }
    }

    outputs.file(installerFile)
}

tasks.register("createLauncherProfile") {
    group = "aris"

    doLast {
        def launcherProfiles = file("aris_run/launcher_profiles.json")

        def profileData = [
                profiles: [
                        forge: [
                                name: "forge",
                                type: "custom",
                                created: new Date().format("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
                                lastUsed: new Date().format("yyyy-MM-dd'T'HH:mm:ss.SSS'Z'"),
                                lastVersionId: mcVersion
                        ]
                ],
                selectedProfile: "forge",
                clientToken: UUID.randomUUID().toString(),
                authenticationDatabase: [:]
        ]

        launcherProfiles.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(profileData))
        println "[ARIS] Created launcher_profiles.json"

        def vanillaVersionDir = file("aris_run/versions/${mcVersion}")
        vanillaVersionDir.mkdirs()

        def versionData = getVersionData(mcVersion)
        def vanillaVersionFile = new File(vanillaVersionDir, "${mcVersion}.json")
        vanillaVersionFile.text = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(versionData))

        println "[ARIS] Created vanilla version JSON"
    }
}

tasks.register("installForge", JavaExec) {
    group = "aris"

    def clientJar = file("aris_run/libraries/net/minecraftforge/forge/${forgeVersion}/forge-${forgeVersion}-client.jar")

    onlyIf {
        !clientJar.exists()
    }

    dependsOn downloadForgeInstaller, createLauncherProfile

    workingDir = file('aris_run')

    def installDir = file("aris_run").absolutePath
    def installerJar = file("forge-installer/forge-${forgeVersion}-installer.jar")

    classpath = files(installerJar)
    mainClass = "net.minecraftforge.installer.SimpleInstaller"

    args = ["--installClient", installDir]

    doFirst {
        println "[ARIS] Running Forge installer..."
        println "[ARIS] This will generate SRG mappings and client files..."
    }
}

def downloadForgeJars(targetDir) {
    def forgeClientUrl = "https://maven.minecraftforge.net/net/minecraftforge/forge/${forgeVersion}/forge-${forgeVersion}-client.jar"
    def forgeClientFile = new File(targetDir, "libraries/net/minecraftforge/forge/${forgeVersion}/forge-${forgeVersion}-client.jar")

    if (!forgeClientFile.exists()) {
        forgeClientFile.parentFile.mkdirs()
        try {
            println "[ARIS] Downloading Forge client JAR..."
            new URL(forgeClientUrl).withInputStream { input ->
                forgeClientFile.withOutputStream { output ->
                    output << input
                }
            }
        } catch (Exception e) {
            println "[ARIS] Cannot found client JAR! " + e.getMessage()
        }
    }

    def forgeUniversalUrl = "https://maven.minecraftforge.net/net/minecraftforge/forge/${forgeVersion}/forge-${forgeVersion}-universal.jar"
    def forgeUniversalFile = new File(targetDir, "libraries/net/minecraftforge/forge/${forgeVersion}/forge-${forgeVersion}-universal.jar")

    if (!forgeUniversalFile.exists()) {
        try {
            println "[ARIS] Downloading Forge universal JAR..."
            new URL(forgeUniversalUrl).withInputStream { input ->
                forgeUniversalFile.withOutputStream { output ->
                    output << input
                }
            }
        } catch (Exception e) {
            println "[ARIS] Note: Universal JAR not found, this is normal for newer versions"
        }
    }
}

tasks.register("arisClient", JavaExec) {
    group = "aris"

    dependsOn setupAris, copyArisModJar

    workingDir = file('aris_run')

    def forgeVersionId = getForgeVersionId(forgeVersion)
    def forgeJsonFile = file("aris_run/versions/${forgeVersionId}/${forgeVersionId}.json")
    def forgeVersionData = new JsonSlurper().parse(forgeJsonFile)

    mainClass = forgeVersionData.mainClass

    def allLibraries = fileTree("aris_run/libraries") {
        include "**/*.jar"
        exclude "**/ForgeAutoRenamingTool*.jar"
        exclude "**/client-${mcVersion}*.jar"
    }

    classpath = allLibraries

    def jvmArgs = []
    def libraryDir = file("aris_run/libraries").absolutePath
    def nativesDir = file("aris_run/natives").absolutePath

    forgeVersionData.arguments.jvm.each { arg ->
        def processedArg = arg
                .replace('${library_directory}', libraryDir)
                .replace('${classpath_separator}', File.pathSeparator)
                .replace('${version_name}', forgeVersionId)

        jvmArgs << processedArg
    }

    jvmArgs.addAll([
            "-Xmx2G",
            "-Xms2G",
            "-Djava.library.path=${nativesDir}"
    ])

    setJvmArgs(jvmArgs)

    def gameArgs = []

    def assetsDir = file("aris_run/assets").absolutePath

    gameArgs.addAll([
            "--username", "ArisDev",
            "--version", forgeVersionId,
            "--gameDir", ".",
            "--accessToken", "0",
            "--assetsDir", assetsDir,
            "--assetIndex", "1.20",
            "--uuid", UUID.randomUUID().toString()
    ])

    gameArgs.addAll(forgeVersionData.arguments.game)
    args = gameArgs
}

tasks.register("setupAris") {
    group = "aris"

    dependsOn downloadMinecraftDependencies
    dependsOn installForge
    doLast {
        println "[ARIS] Setup complete! Forge ${forgeVersion} is ready."
    }
}

tasks.register("cleanOldArisMods", Delete) {
    group = "aris"

    delete fileTree("aris_run/mods") {
        include "aris*.jar"
        include "kotlinforforge*.jar"
    }
}

tasks.register("copyArisModJar", Copy) {
    group = "aris"
    dependsOn remapJar, cleanOldArisMods

    from remapJar.archiveFile
    into "aris_run/mods"

    from configurations.runtimeClasspath.filter {
        it.name.contains("kotlinforforge")
    }
    into "aris_run/mods"
}

// SJhub end - custom mc client for fix native lib loading issue